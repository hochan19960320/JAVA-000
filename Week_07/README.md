学习笔记





MySQL从5.5开始推出了半同步复制。相比异步复制，半同步复制提高了数据完整性，因为很明确知道，在一个事务提交成功之后，这个事务就至少会存在于两个地方。即在master的dumper线程通知slave后，增加了一个ack（消息确认），即是否成功收到t1的标志码，也就是dumper线程除了发送t1到slave，还承担了接收slave的ack工作。**如果出现异常，没有收到ack，那么将自动降级为普通的复制，直到异常修复后又会自动变为半同步复制**。



半同步复制具体特性：

- 从库会在连接到主库时告诉主库，它是不是配置了半同步。
- 如果半同步复制在主库端是开启了的，并且至少有一个半同步复制的从库节点，那么此时主库的事务线程在提交时会被阻塞并等待，结果有两种可能，要么至少一个从库节点通知它已经收到了所有这个事务的Binlog事件，要么一直等待直到超过配置的某一个时间点为止，而此时，**半同步复制将自动关闭，转换为异步复制**。
- 从库节点只有在接收到某一个事务的所有Binlog，将其写入并Flush到Relay Log文件之后，才会通知对应主库上面的等待线程。
- 如果在等待过程中，等待时间已经超过了配置的超时时间，没有任何一个从节点通知当前事务，那么此时主库会自动转换为异步复制，当至少一个半同步从节点赶上来时，主库便会自动转换为半同步方式的复制。
- **半同步复制必须是在主库和从库两端都开启时才行**，如果在主库上没打开，或者在主库上开启了而在从库上没有开启，主库都会使用异步方式复制。

总结：当主从两端都开启了半同步复制(大前提)。复制过程中，1.如果发生问题就降级为异步复制，恢复正常了就转为半同步复制 2.有一个从节点复制完成，也会转换为异步复制。

保证至少一个备份可用！


作业一：基于springboot+druid+aop完成动态切换数据源,实现读写分离

作业二：基于sharding-Jdbc